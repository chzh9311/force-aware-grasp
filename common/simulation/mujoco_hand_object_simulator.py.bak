import os
import time
import numpy as np
import sys

from jedi.settings import dynamic_params

sys.path.append('.')
import trimesh
from lxml import etree
import coacd
import mujoco
import mujoco.viewer
from collections import defaultdict
from matplotlib import pyplot as plt
import quaternion
import copy
import open3d as o3d
from math import asin, sqrt
from tqdm import tqdm
import open3d.visualization as vis
from mujoco import rollout
from easydict import EasyDict as edict
from common.utils.vis import o3dmesh_from_trimesh, o3d_arrow
from common.utils.manolayer import get_part_meshes

kine_tree = {'Index': [0, 1, 2, 3], 'Mid': [0, 4, 5, 6], 'Little': [0, 10, 11, 12],
             'Ring': [0, 7, 8, 9], 'Thumb': [0, 13, 14, 15]}

kine_tree_w_tips = {'Index': [0, 1, 2, 3, 17], 'Mid': [0, 4, 5, 6, 18], 'Little': [0, 10, 11, 12, 20],
             'Ring': [0, 7, 8, 9, 19], 'Thumb': [0, 13, 14, 15, 16]}

## 800N for thumb & palm; 150N for the rest fingers.
force_threshold = [800,] + [150,] * 12 + [800,] * 3

def array2str(array):
    return " ".join([f"{a:.4f}" for a in array])

def run_mujoco_simulate(label_cfg, model_path, hand_mesh, hand_joints, obj_model, obj_hulls, part_ids, part_normals=None, part_dists=None):
    mesh2mjcf(label_cfg.default_mjcf_settings, model_path, hand_mesh, hand_joints, obj_model, obj_hulls, part_ids, part_normals, part_dists)
    frame_info = run_adaptive_sim(model_path, label_cfg.adaptive_sim)
    return frame_info

def mesh2mjcf(default_cfg, model_path, hand_mesh, hand_joints, obj_model, obj_hulls, part_ids, part_normals, part_dists):
    """
    :param hand_params: dict with rot_aa, trans, pose, shape.
    :param mano_layer: mano layer.
    :param obj_mesh: object mesh in trimesh format.
    Saves the current state to MJCF file.
    """
    timestep = default_cfg.timestep
    joint_type = default_cfg.joint_type
    os.makedirs(model_path, exist_ok=True)

    hand_parts = get_part_meshes(hand_mesh.vertices, hand_mesh.faces, part_ids)
    hand_parts = [trimesh.convex.convex_hull(m) for m in hand_parts]
    # hand_parts = [hand_parts[0]] + [trimesh.convex.convex_hull(m) for m in hand_parts[1:]]

    hand_mesh_name = 'hand_model'
    obj_mesh_name = 'obj_model'
    os.makedirs(os.path.join(model_path, hand_mesh_name), exist_ok=True)
    os.makedirs(os.path.join(model_path, obj_mesh_name), exist_ok=True)

    root = etree.Element('mujoco')
    root.set('model', hand_mesh_name)
    compiler = etree.SubElement(root, 'compiler')
    compiler.set('meshdir', '.')
    compiler.set('angle', 'radian')
    compiler.set('autolimits', 'true')

    default_top = etree.SubElement(root, 'default')
    default_hand_class = etree.SubElement(default_top, 'default')

    default_hand_class.set('class', hand_mesh_name)
    default_hand_geom = etree.SubElement(default_hand_class, 'geom')
    default_hand_geom.set('type', 'mesh')
    default_hand_geom.set('rgba', '0.9 0.8 0.6 1')
    default_hand_geom.set('contype', '1')
    default_hand_geom.set('conaffinity', '1')
    for attr in ['solref', 'margin', 'solimp', 'friction']:
        if hasattr(default_cfg, attr):
            default_hand_geom.set(attr, default_cfg[attr])
    # default_hand_geom.set('margin', default_cfg.margin)
    # default_hand_geom.set('solimp', default_cfg.solimp)
    default_joint = etree.SubElement(default_hand_class, 'joint')
    if joint_type != 'rigid':
        default_joint.set('type', joint_type)
    default_joint.set('stiffness', '0')
    default_joint.set('limited', 'true')

    default_obj_class = etree.SubElement(default_top, 'default')
    default_obj_class.set('class', obj_mesh_name)
    default_obj_geom = etree.SubElement(default_obj_class, 'geom')
    default_obj_geom.set('type', 'mesh')
    default_obj_geom.set('rgba', '0.9 0.8 0.6 1')
    default_obj_geom.set('contype', '1')
    default_obj_geom.set('conaffinity', '1')
    default_obj_geom.set('friction', '1. 0.5 0.01')
    # default_joint.set('range' '-0.2, 0.2') ## Approximately 12 degrees
    option = etree.SubElement(root, 'option')
    option.set('timestep', str(timestep))
    flag = etree.SubElement(option, 'flag')
    flag.set('multiccd', 'enable')

    asset = etree.SubElement(root, "asset")

    # actuator = etree.SubElement(root, 'actuator')
    #
    # contact = etree.SubElement(root, 'contact')

    keyframe = etree.SubElement(root, 'keyframe')
    key = etree.SubElement(keyframe, 'key')

    ## hand link to the world coordinate system.
    worldbody = etree.SubElement(root, "worldbody")
    body = etree.SubElement(worldbody, "body")
    body.set('name', 'hand_world')
    body.set('pos', array2str([0, 0, 0]))
    body.set('euler', array2str([0, 0, 0]))

    ## palm
    palm_body = etree.SubElement(body, "body")
    palm_body.set('name', 'Palm_link')

    hand_root_pos = hand_joints[0]
    palm_body.set('pos', array2str(hand_root_pos))
    palm_body.set('euler', array2str([0, 0, 0]))
    # rot_angle = np.linalg.norm(hand_params['rot_aa'].squeeze())
    # rot_axis = hand_params['rot_aa'].squeeze() / (rot_angle + 0.00001)
    # body.set('axisangle', array2str(list(rot_axis) + [rot_angle]))

    # o3d.visualization.draw_geometries([o3dmesh_from_trimesh(hand_parts[0])])
    palm_decompose = False
    if palm_decompose:
        palm_coacd_mesh = coacd.Mesh(hand_parts[0].vertices, hand_parts[0].faces)
        palm_hulls = coacd.run_coacd(palm_coacd_mesh, threshold=0.1)
        for i, hull in enumerate(palm_hulls):
            palm_geom = etree.Element("geom")
            palm_part_mesh = trimesh.Trimesh(hull[0], hull[1])
            palm_part_mesh.apply_translation(-hand_root_pos)
            palm_geom.set('class', hand_mesh_name)
            palm_geom.set('name', f'palm_geom_{i}')

            palm_mesh_leaf = etree.Element("mesh")
            palm_mesh_leaf.set('name', f'palm_hull_{i}')
            palm_mesh_leaf.set('file', os.path.join(hand_mesh_name, f'palm_hull_{i}.stl'))
            asset.append(palm_mesh_leaf)

            palm_geom.set('mesh', f'palm_hull_{i}')
            palm_part_mesh.export(os.path.join(model_path, hand_mesh_name, f'palm_hull_{i}.stl'))
            palm_body.append(palm_geom)
    else:
        palm_part_mesh = hand_parts[0]
        palm_geom = etree.Element("geom")
        palm_part_mesh.apply_translation(-hand_root_pos)
        palm_geom.set('class', hand_mesh_name)
        palm_geom.set('name', f'palm_geom')

        palm_mesh_leaf = etree.Element("mesh")
        palm_mesh_leaf.set('name', f'palm_hull')
        palm_mesh_leaf.set('file', os.path.join(hand_mesh_name, f'palm_hull.stl'))
        asset.append(palm_mesh_leaf)

        palm_geom.set('mesh', f'palm_hull')
        palm_part_mesh.export(os.path.join(model_path, hand_mesh_name, f'palm_hull.stl'))
        palm_body.append(palm_geom)

    joint_k = []
    for fg_name, ktree in kine_tree.items():
        parent_body = palm_body
        root_coord = hand_root_pos
        for i, jt in enumerate(ktree):
            if i == 0:
                continue
            finger_mesh = hand_parts[jt]
            finger_mesh.apply_translation(- hand_joints[jt])
            finger_mesh_leaf = etree.Element('mesh')
            finger_mesh_leaf.set('name', fg_name + f"_hull_{i}")
            finger_mesh_leaf.set('file', os.path.join(hand_mesh_name, f"{fg_name}_hull_{i}.stl"))
            asset.append(finger_mesh_leaf)

            finger_body = etree.SubElement(parent_body, "body")
            finger_body.set('name', fg_name + f"_link_{i}")
            finger_body.set('pos', array2str(hand_joints[jt] - root_coord))
            # finger_body.set('pos', array2str([0, 0, 0]))
            finger_body.set('euler', array2str([0, 0, 0]))
            ## gravity compensation set to 1 to avoid the effect of self-gravity.
            finger_body.set('gravcomp', '1')

            finger_geom = etree.Element("geom")
            finger_geom.set('class', hand_mesh_name)
            finger_geom.set('name', fg_name + f"_geom_{i}")
            finger_geom.set('mesh', fg_name + f"_hull_{i}")
            finger_body.append(finger_geom)

            # Assume only one joint for the thumb.
            # finger_obj_dist = part_dists[jt].item()

            # if finger_obj_dist < -0.001:
            #     ## Solve penetrations
            #     obj_normal = part_normals[jt]
            #     finger_joint = etree.Element("joint")
            #
            #     if joint_type == 'rigid':
            #         ## Make slight shifts to confirm contact
            #         finger_mesh.apply_translation(- obj_normal * finger_obj_dist)
            #     else:
            #         if joint_type == 'hinge':
            #             joint2tip = hand_joints[jt] - hand_joints[ktree[i-1]]
            #             hinge_axis = np.cross(obj_normal, joint2tip)
            #             hinge_axis /= np.linalg.norm(hinge_axis, axis=-1, keepdims=True) + 1.0e-6
            #             finger_joint.set('axis', array2str(hinge_axis))
            #             error_angle = np.arcsin(finger_obj_dist / np.linalg.norm(joint2tip)).item()
            #             joint_k.append(error_angle * 2 / 3)
            #             finger_joint.set('range', f'{error_angle:.4f} 0.00')
            #
            #         elif joint_type == 'slide':
            #             finger_joint.set('axis', array2str(-obj_normal))
            #             finger_joint.set('range', f'{finger_obj_dist*0.9:.4f} 0.0000')
            #             joint_k.append(finger_obj_dist * 0.9)
            #
            #         finger_joint.set("class", hand_mesh_name)
            #         finger_joint.set('name', f'{fg_name}_joint_{i}')
            #         finger_joint.set('pos', array2str([0, 0, 0]))
            #         finger_joint.set('stiffness', '5')
            #         finger_body.append(finger_joint)
            #
            #         motor = etree.Element("motor")
            #         motor.set('name', f'{fg_name}_motor_{i}')
            #         motor.set('joint', f'{fg_name}_joint_{i}')
            #         motor.set('gear', '1 0 0 0 0 0')
            #         actuator.append(motor)
            #         exclude_contact = etree.Element("exclude")
            #         exclude_contact.set('name', f'{fg_name}_exclude_{i}')
            #         exclude_contact.set('body1', f'{fg_name}_link_{i}')
            #         if i == 1:
            #             exclude_contact.set('body2', 'Palm_link')
            #         else:
            #             exclude_contact.set('body2', f'{fg_name}_link_{i - 1}')
            #         contact.append(exclude_contact)
            #
            finger_mesh.export(os.path.join(model_path, hand_mesh_name, f'{fg_name}_hull_{i}.stl'))
            parent_body = finger_body
            root_coord = hand_joints[jt]

    joint_k.extend([0, 0, 0, 1, 0, 0, 0])
    key.set('name', 'Fixed H-O pose')
    key.set('qpos', array2str(joint_k))

    ## Object mesh
    # obj_coacd_mesh = coacd.Mesh(obj_mesh.vertices, obj_mesh.faces)
    # obj_hulls = coacd.run_coacd(obj_coacd_mesh)
    body = etree.SubElement(worldbody, "body")
    body.set('name', 'object')

    ## The object is floating
    obj_free_joint = etree.Element('joint')
    obj_free_joint.set('type', 'free')
    obj_free_joint.set('name', 'object2world')
    # obj_free_joint.set('stiffness', '20')
    obj_free_joint.set('damping', '1')
    body.append(obj_free_joint)

    # inertial = etree.Element('inertial')
    # inertial.set('pos', array2str(obj_model.center_mass))
    # inertial.set('mass', '1.0') # object masses are fixed to 1kg.
    # inertial.set('quat', '1.0 0 0 0')

    ## Constructing scene with plane
    # planebody = etree.SubElement(worldbody, "body")
    # plane = etree.SubElement(planebody, "geom")
    # plane.set('type', 'plane')
    # plane.set('size', '0 0 1')
    # plane.set('pos', '0 0 -0.5')
    # plane.set('friction', '1. 0.5 0.01')
    # total_vol = sum([hull.volume for hull in obj_hulls])
    # density = 1 / total_vol # Ensure the object is 1kg and of even density.

    for i in range(len(obj_hulls)):
        # convex_hull = trimesh.Trimesh(obj_hulls[i][0], obj_hulls[i][1])
        convex_hull = obj_hulls[i]
        convex_hull_name = f"obj_hull_{i}"
        convex_hull_mesh = etree.Element("mesh")
        convex_hull_mesh.set("name", convex_hull_name)
        convex_hull_mesh.set(
            "file", f"{obj_mesh_name}/{convex_hull_name}.stl")
        asset.append(convex_hull_mesh)
        convex_hull.export(os.path.join(model_path, obj_mesh_name, f'{convex_hull_name}.stl'))

        convex_hull_geom = etree.Element("geom")
        convex_hull_geom.set("type", "mesh")
        convex_hull_geom.set("mesh", convex_hull_name)
        convex_hull_geom.set("class", obj_mesh_name)
        # convex_hull_geom.set('density', str(density))
        body.append(convex_hull_geom)

    tree = etree.ElementTree(root)
    etree.indent(tree, space="  ", level=0)
    with open(os.path.join(model_path, "hand_model.xml"), "wb") as files:
        tree.write(files)

def run_sim(model_path, visualize=False):
    ## Options
    dist_stable_time = 1 # second
    dist_stable_th = 0.001
    force_sample_steps = 100

    model = mujoco.MjModel.from_xml_path(os.path.join(model_path, "hand_model.xml"))
    timestep = model.opt.timestep
    data = mujoco.MjData(model)
    # data.qpos = 0.01
    jt = model.joint('object2world')
    # jt.stiffness = 50
    obj_body = data.body('object')
    # data.ctrl = 5
    # data.ctrl = 1
    # data.actuator_force = 10
    # visualize contact frames and forces, make body transparent
    # tweak scales of contact visualization elements

    # mujoco.mj_resetDataKeyframe(model, data, 0)
    slow_rate = 10
    if visualize:
        model.vis.scale.contactwidth = 0.1
        model.vis.scale.contactheight = 0.03
        model.vis.scale.forcewidth = 0.02
        model.vis.map.force = 0.01
        viewer = mujoco.viewer.launch_passive(model, data)
        viewer.opt.flags[mujoco.mjtVisFlag.mjVIS_CONTACTFORCE] = True
        viewer.opt.flags[mujoco.mjtVisFlag.mjVIS_TRANSPARENT] = True

    disps = []
    obj_qpos = []
    forcetorque = np.zeros(6)
    stable = False
    dynamic_conatct_info = []
    step_cnt = 0
    n_stable_step = dist_stable_time / timestep
    # print('start simulation...')

    while not visualize or viewer.is_running():
        step_start = time.time()
        mujoco.mj_step(model, data)
        disp = obj_body.xpos
        if len(disps) >= n_stable_step and not stable:
            if np.linalg.norm(disps[0] - disps[-1]) < dist_stable_th:
                ## Stable
                stable = True
                print("Pose stable")
        else:
            disps.append(disp)
        if visualize:
            viewer.sync()

        if stable and step_cnt < force_sample_steps:
            contact_info = []
            for j, c in enumerate(data.contact):
                mujoco.mj_contactForce(model, data, j, forcetorque)
                if c.geom1 < 16 <= c.geom2:
                    hpart = c.geom1
                elif c.geom2 < 16 <= c.geom1:
                    hpart = c.geom2
                else:
                    continue
                contact_info.append({ 'frame': c.frame,
                    'part_id': hpart, 'force': forcetorque[0:3], 'contact_pt': c.pos
                })
            dynamic_conatct_info.append(contact_info)
            obj_qpos.append(data.joint('object2world').qpos.copy())
            step_cnt += 1

        time_until_next_step = slow_rate * model.opt.timestep - (time.time() - step_start)
        if visualize and time_until_next_step > 0:
            time.sleep(time_until_next_step)

        if step_cnt > force_sample_steps - 1 and not visualize:
            # print(np.mean(force, axis=0))
            break

    # force_abs = np.linalg.norm(force, axis=-1)
    # plt.plot(np.arange(self.force_sample_steps), force_abs)
    # plt.show()
    return dynamic_conatct_info, np.stack(obj_qpos, axis=0)


def run_adaptive_sim(model_path, ada_cfg):
    """
    Search for the best global stiffness.
    """
    sim_time = 1 # second

    model = mujoco.MjModel.from_xml_path(os.path.join(model_path, "hand_model.xml"))
    total_steps = int(sim_time / model.opt.timestep)
    data = mujoco.MjData(model)

    # start_ratio2 = time_ratio2[np.argmin(np.array(disps))]
    contact_geom_ids = []
    mujoco.mj_step(model, data)
    for j, c in enumerate(data.contact):
        if c.geom1 < 16 <= c.geom2 and c.geom1 not in contact_geom_ids:
            contact_geom_ids.append(c.geom1)
        elif c.geom2 < 16 <= c.geom1 and c.geom1 not in contact_geom_ids:
            contact_geom_ids.append(c.geom2)
        mujoco.mj_resetDataKeyframe(model, data, 0)
    if ada_cfg.use_ada_solref:
        time_ratios = np.exp(np.linspace(ada_cfg.coarse_search_range[0], ada_cfg.coarse_search_range[1], ada_cfg.coarse_nbins))
        _, opt_idx = run_simulations_w_param(model, data, contact_geom_ids, time_ratios, total_steps, ada_cfg.label_strategy, ret_label=False)
        ## If the min displacement > 5 cm, then we can further search for the best disp.
        if opt_idx == 0:
            new_trs = np.linspace(time_ratios[opt_idx] * 0.1, time_ratios[opt_idx + 1], ada_cfg.fine_nbins)
        elif opt_idx == len(time_ratios) - 1:
            new_trs = np.linspace(time_ratios[opt_idx-1], time_ratios[opt_idx] * 1.2, ada_cfg.fine_nbins)
        else:
            new_trs = np.linspace(time_ratios[opt_idx-1], time_ratios[opt_idx + 1], ada_cfg.fine_nbins)

        frame_info, opt_idx = run_simulations_w_param(model, data, contact_geom_ids, new_trs, total_steps, ada_cfg.label_strategy)
        # tps = np.array([labels[i]['total_pressure'] for i in range(len(labels))])
        # opt_idx = np.argmin(tps)
        # frame_info = {'contacts': labels[opt_idx]['contact'], 'obj_disp': final_qposes[opt_idx],
        #               'label_obj_disp': label_qposes[opt_idx], 'stable': stable}
        # print('force:', tps[opt_idx])
        # print('disp:', np.linalg.norm(label_qposes[opt_idx][:3] * 100))
    else:
        frame_info, opt_idx = run_simulations_w_param(model, data, contact_geom_ids, None, total_steps, ada_cfg.label_strategy)


    return frame_info
    # return dynamic_contact_info, np.stack(obj_qpos, axis=0)
    # nr = len(rel_ratio2)
    # ng = len(contact_geom_ids)
    # n_batches = nr ** ng
    # mujoco.mj_resetDataKeyframe(model, data, 0)
    # init_states = get_state(model, data, n_batches)
    # mjdatas = [copy.copy(data) for _ in range(20)]
    # models = []
    # disps = []
    # spec = mujoco.MjSpec.from_file(os.path.join(model_path, "hand_model.xml"))
    # for b in tqdm(range(n_batches)):
    #     for i, gid in enumerate(contact_geom_ids):
    #         model.geom(gid).solref[1] = sqrt(start_ratio2 * rel_ratio2[int(b // nr ** i) % nr])
    #     mujoco.mj_resetDataKeyframe(model, data, 0)
    #     for _ in range(total_steps):
    #         mujoco.mj_step(model, data)
    #     disps.append(np.linalg.norm(data.joint('object2world').qpos[:3]))
    #     print(disps[-1])
    # print(min(disps))
    # state, _ = rollout.rollout(models, mjdatas, init_states, nstep=total_steps)
    # print(state.shape)


def run_simulations_w_param(model, data, contact_geom_ids, solref_list, total_steps, label_strategy='min_disp', ret_label=True):
    """
    run adaptive simulation
    Labels include: least force when disp < 1cm; least force when disp < 5cm.
    return: the least force.
    """
    labels = []
    label_idxs = []
    all_qpos = []
    if solref_list is None:
        solref_list = [model.geom(0).solref[1]]
    for t in solref_list:
        for gid in contact_geom_ids:
            model.geom(gid).solref[1] = t
        mujoco.mj_resetDataKeyframe(model, data, 0)
        obj_qpos = []
        dynamic_contact_info = []
        forcetorque = np.zeros(6)
        for i in range(total_steps):
            contact_info = []
            mujoco.mj_step(model, data)
            if label_strategy == 'min_pressure':
                for j, c in enumerate(data.contact):
                    mujoco.mj_contactForce(model, data, j, forcetorque)
                    if c.geom1 < 16 <= c.geom2:
                        hpart = c.geom1
                    elif c.geom2 < 16 <= c.geom1:
                        hpart = c.geom2
                    else:
                        continue
                    contact_info.append({'frame': c.frame.copy(), 'part_id': hpart,
                                         'force': forcetorque[0:3].copy(), 'contact_pt': c.pos.copy()
                                         })
                dynamic_contact_info.append(contact_info)
            obj_qpos.append(data.joint('object2world').qpos.copy())
        ## Aggregate info
        obj_disps = np.array([np.linalg.norm(qp[:3]) for qp in obj_qpos])
        if label_strategy == 'min_pressure':
            label, label_idx = get_stage_label(dynamic_contact_info, obj_disps, 0.01)
            label_idxs.append(label_idx)
            labels.append(label)
        all_qpos.append(np.stack(obj_qpos, axis=0))

    all_qpos = np.stack(all_qpos, axis=0)
    disps = np.linalg.norm(all_qpos[:, :, :3], axis=-1)

    # labelling stage
    if label_strategy == 'min_pressure':
        if np.min(disps[:, -1]) >= 0.05:
            opt_idx = np.argmin(disps[:, -1])
            stable = False
        else:
            tps = np.array([labels[i]['total_pressure'] if disps[i, -1] < 0.05 else 100000 for i in range(len(labels))])
            opt_idx = np.argmin(tps)
            stable = True
        ref_frame = label_idxs[opt_idx]
        frame_info = {'contacts': labels[opt_idx], 'obj_disp': all_qpos[opt_idx, -1], 'label_frame':ref_frame,
                      'label_obj_disp': all_qpos[opt_idx, ref_frame], 'stable': stable}
    elif label_strategy == 'min_disp':
        opt_idx = np.argmin(disps[:, -1])
        if ret_label:
            stable = 1
            labelled = False
            label_idx = all_qpos.shape[1]
            for gid in contact_geom_ids:
                model.geom(gid).solref[1] = solref_list[opt_idx]
            mujoco.mj_resetDataKeyframe(model, data, 0)
            dynamic_contact_info = []
            obj_qpos = []
            for i in range(total_steps):
                contact_info = []
                mujoco.mj_step(model, data)
                for j, c in enumerate(data.contact):
                    mujoco.mj_contactForce(model, data, j, forcetorque)
                    if c.geom1 < 16 <= c.geom2:
                        hpart = c.geom1
                    elif c.geom2 < 16 <= c.geom1:
                        hpart = c.geom2
                    else:
                        continue
                    contact_info.append({'frame': c.frame.copy(), 'part_id': hpart,
                                         'force': forcetorque[0:3].copy(), 'contact_pt': c.pos.copy()
                                         })
                dynamic_contact_info.append(contact_info)
                obj_qpos.append(data.joint('object2world').qpos.copy())
            obj_qpos = np.stack(obj_qpos, axis=0)
            for idx, disp in enumerate(disps[opt_idx]):
                if disp > 0.01 and not labelled: # ensure the force are labelled within 1 cm of displacement.
                    label_idx = idx + 1
                    labelled = True
                if disp > 0.05: # 5cm as an empirical threshold.
                    stable = 0
                    break
            feasible_pos = obj_qpos[:label_idx, :3]
            if label_idx > 10:
                ## Use the frame with the least acceleration.
                vec = feasible_pos[1:] - feasible_pos[:-1]
                acc = np.linalg.norm(np.stack(vec[1:] - vec[:-1], axis=0), axis=1)
                ref_frame = np.argmin(acc)+1
            else:
                ref_frame = label_idx
            label_contact = dynamic_contact_info[ref_frame]
            frame_info = {'contacts': label_contact, 'obj_disp': obj_qpos[-1], 'label_frame':ref_frame,
                          'label_obj_disp': obj_qpos[ref_frame], 'stable': stable}
        else:
            frame_info = None
    else:
        raise NotImplementedError
    return frame_info, opt_idx


def get_stage_label(dynamic_contact_info: list, disps: np.ndarray, stage=0.01):
    """
    get the least force w.r.t. disp < stages
    """
    total_pressure = []
    for d in dynamic_contact_info:
        total_pressure.append(sum([c['force'][0] for c in d]))
    total_pressure = np.array(total_pressure)

    mask = disps < stage
    opt_idx = np.argmin(total_pressure[mask])
    label = {'contact': list_bool_idx(dynamic_contact_info, mask)[opt_idx]}
    label['total_pressure'] = total_pressure[mask][opt_idx]

    return label, opt_idx


def list_bool_idx(l: list, idx: np.ndarray):
    return [l[i] for i in range(len(l)) if idx[i]]


def get_state(model, data, nbatch=1):
  full_physics = mujoco.mjtState.mjSTATE_FULLPHYSICS
  state = np.zeros((mujoco.mj_stateSize(model, full_physics),))
  mujoco.mj_getState(model, data, state, full_physics)
  return np.tile(state, (nbatch, 1))

if __name__ == '__main__':
    ada_cfg = edict({'use_ada_solref': True, 'coarse_search_range': (-3, 3), 'coarse_nbins': 30, 'fine_nbins': 30})
    # label_info, label_qpos, final_qpos = run_adaptive_sim('tmp/grab/0015', ada_cfg)
    # print(label_info)
    # print(rollout.rollout.__doc__)
    run_sim('tmp/grab/0004', True)
    # simulator.simulate(None, None, None, None, None, None)
